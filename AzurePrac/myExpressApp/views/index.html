<!DOCTYPE html>
<html>
    <h1>
        On learning in general.
    </h1>
    <h2> Why? </h2>
    <p> 
        Ultimately, it's not only our programs that needs to be scalable/maintanable,
        but also our learnings in computer science that needs to be scalable/maintainable.
    </p>
    <br/>
    <h3> Regarding abstrations. </h3>
    <p>
        According to SICP, concept is abstracted when all the concepts those are attched to the target concept are detached. <br/>
        When a concept reaches this state, we can now play around with it however we want, enabling us to scale concepts on top of other without interference; <br/>
        because of this, we must strive abstract the concept we are trying to learn as much as we can.
        <br/><br/><br/>
        In this context, concepts could be considered as software utility/programming methodologies/etc ...
        <br/><br/>
    </p>
    <p>
        Focusing on what you don't know also can be understood as NOT focusing on what you don't know, causing it to detoriate.
    </p>
    <h3> Regarding the concepts that increases your growth significantly. </h3>
    <p>
        In all obviousness, if one is taking their learning seriously, they are going to learn everyday, 
        no matter what.
        <br/><br/><br/>
        But there are types of learning that enables a programmer to drastically grow in a short
        amount of time.
        <br/><br/><br/>
        For example, programming at a hackathon enables a programmer to learn a lot in
        a short amount of time.
        <br/><br/><br/>
        Another example is a type of learning that enables to gain deeper insight on
        computer science in general; for example, being able to write a program in ARM
        enables a programmer to intuitive understand how mechanism of a computer
        architecture works.
        <br/><br/><br/>
        I am pretty sure there are more, but I can't think of every one of them.
    </p>
    <h3> In my opinion ... </h3>
    <p>    
        There are two types of concepts.
        <br/><br/><br/>
        Concepts those are needed to be learned in depth and focus,
        and there are concepts those are supposed to learned as you go.
        <br/><br/><br/>
        Gradle and XML in Android aren't supposed to be taken in depth,
        but the language and Android as a platform needs to be learned 
        in depth and focus.
        <br/><br/><br/>
        The reason why this needs to be distinguished is because to conserve time,
        and actually investing time in the concepts are those needs to be taken in precedence.
        <br/><br/><br/>
        This software engineering industry and academia we are in is being progressed by companies and key individuals.
        It might be my interest to keep my eyes one them; perhaps, even predict their next move.
    </p>
    <h3> Videos. </h3>
    <a href="https://www.youtube.com/watch?v=WELBnE33dpY"> GOTO 2019 • Intro to Empirical Software Engineering: What We Know We Don't Know • Hillel Wayne </a>
    <br/>
    <a href="https://www.youtube.com/watch?v=YCQMiFF9QXM"> GOTO 2019 • How Thinking Small is Changing Software Development Big Time • Sander Hoogendoorn </a>
    <h1>
        I find Google tutorials unhelpful.
    </h1>
    <br/>
    <p>
        I remember trying to get my AR app working during the XR hackathon by following along their code lab,<br/>
        but ended up spending about 5+ hours with my teammates and eventually getting stuck on the OpenGL portion. <br/>
        There was clearly a better way to solve whatever we were trying to solve via Sceneform, but tutorial contained nothing of that. 
        <br/><br/><br/>
        In the end, thank God, I was fortunate enough to find a good Medium article on AR to play around with cloud anchors.
        <br/><br/><br/>
        Despite the fact that Retrofit is more used in the industry, I still remember that their official documentation was teaching Volley (not that I have anything against their library).
        <br/><br/><br/>
        At the sametime, I learned how to program Android via using Udacity, instead of using their "getting started."
        <br/><br/><br/>
        Is it just me having this much bad experience with their tutorials?
    </p>
</html>
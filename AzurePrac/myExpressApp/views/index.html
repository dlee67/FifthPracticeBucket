<!DOCTYPE html>
<html>
    <h1>
        On learning in general.
    </h1>
    <h2>
        스터디 코드를 다시한번 관심같기 시작했는데
    </h2>
    <p>
        Like, their entire principals on learning. <br/>
        Where it's not really about the smartness, but it's more about recognizing that <br/>
        you are a human, and quit trying to sleep 5 hours a day. <br/><br/>

        일단, 6시 30분이 내 최소수면시간인것같다.<br/><br/>

        내가 시스템에서부터 원하는걸 얻어야하는게 있는것처럼, 시스템도 나한테 필요한게있다.<br/>
        애초당시 한국고등학교에서 서울대보낸 학생들을 왜 자랑하느냐? 돈들어오고 학생들오니깐.<br/>
        <a href="https://www.youtube.com/watch?v=gIAuGs8WL44&list=PLt7VujzO3zZWpb7YM9ZI3_Dql9tMDUWDG&index=3&t=0s">최상위권이란...</a><br/><br/>

        45분을 일/공부에 몰두하고 15분을 휴식. 이건번갈아가며 했더니 엄청나게 많은양에 일을 끝냈다. <br/><br/>

        서울대 학생들은 맨날 4시간만잔 공부 괴물들인줄알았느냐?<br/>
        물론, 그거랑 거리가 멀며, 자기의 나약함을 인정하고 파회법을 만들고 사용한것뿐이다.
    </p>
    <h2>On individualism and learning</h2>
    <p>
        I always tried to copy John, where he was able to learn things in a short amount of time.<br/><br/>

        But, later on, he told me that
        it's due to his accumulated wisdom to recognize 
        what is the right learning/programming to do at the moment<br/><br/>

        But for some strange reason, I still tried to copy his results, instead of his actions ... <br/><br/>

        I should've known earlier to stop trying to copy others.
    </p>
    <h2>On focus</h2>
    <p>
        Also, I need to admit being a human means to loose focus, 
        where my focus need to be in a form of oscillation.<br/>
        <a href="https://www.youtube.com/watch?v=fLvd5bpRV4Y">it's in Korean.</a><br/><br/>

        When I am learning something new, 
        I need to have a clear goal, 
        and read/write to achieve that goal.<br/><br/>

        For example, when reading a new book, 
        if reading cover to cover is not the objecting, 
        then only pick out the info those are needed for my learning<br/><br/>

        The point is to carve out the unnecessary learnings, and optimize peak focus time.
    </p>
    <h2>Concepts of tree</h2>
    <p>
        Whatever code/GUI I look at, I need to start generating the "branching tree of concepts," in my head <br/>
        Meaning, when I look at BrowserWindow, I need to start drawing a tree in my head, notifying myself things like ... <br/><br/>

        BrowserWindow can be transparent ... <br/>
        can have backgroud colors ... <br/>
        can change fontsize ... <br/><br/>

        in a form of tree. In a form of tree because node can branch out to something ...
    </p>
    <h2> Not exactly related to learning but ...</h2>
    <p>
        Linus Torvald is recognized in the communities, not because he's Kung-fu nasty with C programming,
        but because he made (well, organized, to be precise) Linux.
    </p>
    <h2> Why? </h2>
    <p> 
        Ultimately, it's not only our programs that needs to be scalable/maintanable,
        but also our learnings in computer science that needs to be scalable/maintainable.
    </p>
    <h2>
        My laundary list:
    </h2>
    <p>
        GRE - Feb - HP <br/>
        C++ and Qt for Ben - Feb - LP <br/>
        CI - for VED - Jab 30 - MP <br/>
    </p>
    <h2>
        I become more productive ...
    </h2>
    <p>
        when I am stressed, it seems like. <br/><br/>

        When my head spins a little, my heart is uncomfortable (just a tiny bit), and I feel depressed (just a tiny bit),
        it seems like I can focus more.
    </p>
    <br/>
    <h3> Regarding abstrations. </h3>
    <p>
        According to SICP, concept is abstracted when all the concepts those are attched to the target concept are detached. <br/>
        When a concept reaches this state, we can now play around with it however we want, enabling us to scale concepts on top of other without interference; <br/>
        because of this, we must strive abstract the concept we are trying to learn as much as we can.
        <br/><br/><br/>
        In this context, concepts could be considered as software utility/programming methodologies/etc ...
        <br/><br/>
    </p>
    <p>
        Focusing on what you don't know also can be understood as NOT focusing on what you don't know, causing it to detoriate.
    </p>
    <h3> Regarding the concepts that increases your growth significantly. </h3>
    <p>
        In all obviousness, if one is taking their learning seriously, they are going to learn everyday, 
        no matter what.
        <br/><br/><br/>
        But there are types of learning that enables a programmer to drastically grow in a short
        amount of time.
        <br/><br/><br/>
        For example, programming at a hackathon enables a programmer to learn a lot in
        a short amount of time.
        <br/><br/><br/>
        Another example is a type of learning that enables to gain deeper insight on
        computer science in general; for example, being able to write a program in ARM
        enables a programmer to intuitive understand how mechanism of a computer
        architecture works.
        <br/><br/><br/>
        I am pretty sure there are more, but I can't think of every one of them.
    </p>
    <h3> In my opinion ... </h3>
    <p>    
        There are two types of concepts.
        <br/><br/><br/>
        Concepts those are needed to be learned in depth and focus,
        and there are concepts those are supposed to learned as you go.
        <br/><br/><br/>
        Gradle and XML in Android aren't supposed to be taken in depth,
        but the language and Android as a platform needs to be learned 
        in depth and focus.
        <br/><br/><br/>
        The reason why this needs to be distinguished is because to conserve time,
        and actually investing time in the concepts are those needs to be taken in precedence.
        <br/><br/><br/>
        This software engineering industry and academia we are in is being progressed by companies and key individuals.
        It might be my interest to keep my eyes one them; perhaps, even predict their next move.
    </p>
    <h3> Videos. </h3>
    <a href="https://www.youtube.com/watch?v=WELBnE33dpY"> GOTO 2019 • Intro to Empirical Software Engineering: What We Know We Don't Know • Hillel Wayne </a>
    <br/>
    <a href="https://www.youtube.com/watch?v=YCQMiFF9QXM"> GOTO 2019 • How Thinking Small is Changing Software Development Big Time • Sander Hoogendoorn </a>
    <br/>
    <a href="https://www.youtube.com/watch?v=unpJ9qRjdMw"> RubyConf 2019 - The Fewer the Concepts, the Better the Code by David Copeland </a>
    <h1>
        I find Google tutorials unhelpful.
    </h1>
    <br/>
    <p>
        I remember trying to get my AR app working during the XR hackathon by following along their code lab,<br/>
        but ended up spending about 5+ hours with my teammates and eventually getting stuck on the OpenGL portion. <br/>
        There was clearly a better way to solve whatever we were trying to solve via Sceneform, but tutorial contained nothing of that. 
        <br/><br/><br/>
        In the end, thank God, I was fortunate enough to find a good Medium article on AR to play around with cloud anchors.
        <br/><br/><br/>
        Despite the fact that Retrofit is more used in the industry, I still remember that their official documentation was teaching Volley (not that I have anything against their library).
        <br/><br/><br/>
        At the sametime, I learned how to program Android via using Udacity, instead of using their "getting started."
        <br/><br/><br/>
        Is it just me having this much bad experience with their tutorials?
    </p>
</html>
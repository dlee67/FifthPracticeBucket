<!DOCTYPE html>
<html>
    <h1>
        My learning progress
    </h1>
    <p>
        Was going over this book called Learning Devops (published by Packt), <br/>
        but I didn't like, so I switched over to Testing Angular Application, published by Mannings. <br/> <br/>
        
        I am currently going over the section 3, which has to do with continous integration, where it wants me to install Jenkins.<br/>
        <a href="https://jenkins.io/doc/book/installing/#installing-jenkins">Installing Jenkins</a><br/><br/>

        I am going over the <h3>On macOS and Linux</h3>, and completed the step 1 and 2, where I just have to go over the Jenkins post installation. <br/>
        I tried to spin docker run jenkinsci/blueocean, but told me this: <br/><br/>

        Jenkins initial setup is required. An admin user has been created and a password generated.
        Please use the following password to proceed to installation: <br/>

        This may also be found at: /var/jenkins_home/secrets/initialAdminPassword <br/><br/>
        
        And I am stuck on this for a while, and decided to just install the thing locally. <br/><br/>

        Been making some progress with the below: <br/>
        <a href="https://www.digitalocean.com/community/tutorials/how-to-install-jenkins-on-ubuntu-18-04">Digital Ocean Jenkins tutorial</a>

        Had to restart my computer for some reason and by using systemctl, I was able to get the thing spinning, with the help of below: <br/>
        <a href="https://wiki.jenkins.io/display/JENKINS/Logging">Jenkins loggins</a>

        Hmm, don't know if this is a good place to jot this but ... <br/>
        username: bob <br/>
        password: 1234 <br/>
        localhost:9000 <br/><br/>

        Jenkins is ready!
        <h3> Jenkins is now there, but the book expects you to complete the previous 2 sections.</h3>
    </p>
    <h1>
        Devops journal
    </h1>
    <h3>
        Ansible
    </h3>
    <p>
        Ansible is not CI related tool, nor CD related tool, but it's something called IaC. <br/><br/>
        
        Azure is nice enough that its cloud shell already has Ansible in it.<br/><br/>

        It has a configuration files stored in /etc/ansible/, where I can easily access it via ansible-config view. <br/><br/>

        Ansible has this thing called inventory files, which is essentially a host, orchestrated via Ansible. <br/><br/>

        There is this concept called playbook in Ansibe, that almost always gets coupled with inventory files, <br/><br/>
        where the playbook contains the actions to be executed for Ansible.
    </p>
    <h3>
        Angular
    </h3>
    <p>
        fixture - Stores an instance of the ComponentFixture, which contains methods that help you debug and test a component <br/>
        Essentially, fixture in testing frameworks provides everything that the unit needs to be tested. <br/>
        <a href="https://en.wikipedia.org/wiki/Test_fixture"> Wiki on test fixtures</a> <br/><br/>
    
        fake - is an object you use in a test to substitute for the real thing. <br/><br/>

        mock - is a fake that simulates the real object and keeps track of when it’s called and what arguments it receives. <br/><br/>
        
        stub - is a simple fake with no logic, and it always returns the same value. <br/><br/>
        
        However, the above concepts are not specific to Angular, it's a general concepts in testing.<br/><br/>

        fakeAsync - Using fakeAsync ensure that all asynchronous tasks are completed before executing the assertions.<br/><br/>

        It's done like ... <br/><br/>

        describe('loadContact() test', () => {<br/>
            it('should load contact', fakeAsync(() => { <br/>
              component.isLoading = false; <br/>
              component.loadContact(); <br/>
              fixture.detectChanges(); <br/>
            }));<br/>
          });<br/><br/>

        declarations section - that's where I can list the components that the components I am testing need.<br/><br/>

        imports section - sets imports to an array of modules that the component my testing requires.<br/><br/>

        provider section - I can chuck in things like services are in there, those are all "fakes." <br/><br/>

        https://angular.io/api/core/testing/tick The left is suppose to be super useful. <br/><br/>
    </p>
    <h4>
        Angular has directives
    </h4>
    <p>
        Directives are like ... <br/>
        1.) Components <br/>
        2.) Structural directives <br/>
        3.) Attribute directives <br/><br/>

        Components are types of directives, which is a directive that's visible on the browser.<br/><br/>

        There are two types of directives,<br/>
        attributes directives - for changing appearance of a DOM element.<br/>
        structural directives - adds or remove elements from DOM.<br/><br/>

        In the world of testing, I'll need fresh fixtures for each tests.<br/>
        This can be done via beforeEach().<br/><br>

        To make sure those fixture objects are destroyed, we use afterEach() functions.
    </p>
    <h4>
        Just finished the Ch 4, but I wasn't able to fully digest what they wanted me to learn.
    </h4>
    <p>
        From the looks of things, I am guessing they wanted me to learn how to test attribute directives.
    </p>
    <h4>
        Just finished Ch 5. They talked about testing pipes.
    </h4>
    <a href="https://angular.io/guide/pipes">pipes</a>
    <h4>
        Ch 6
    </h4>
    <p>
        This chapter answers the question on why we need dependency injection. <br/><br/>

        The books describes that the reason why DI is needed is because, almost always, <br/>
        we have no idea what we need for our app, so, it might be better to store everything we might need <br/>
        in one place, and have those be injected whenever my app needs'em.<br/><br/>

        <a href="https://github.com/testing-angular-applications/testing-angular-applications/blob/master/chapter06/src/app/contacts/shared/services/contact.service.spec.ts">
            testing-angular-application/chapter06/src/app/contacts/shared/services/contact.service.spec.ts
        </a>
        <br/><br/>

        The above demonstrates on how one can tests Observables and asynchronous behaviors in Angular.
    </p>
    <h4>
        Just finished skimming Ch 7 today, <br/>
        and I can't help but to feel that I should actually go learn more about Angular.
    </h4>
    <h4> ch 10 </h4>
    <p>
        Ch 8-9 are about UI testing and synchrounous/asynchrounous stuff.<br/>
        Ultimately whatever Espresso can do in Android, Protractor can do also. <br/><br/>

        Ch 10 introduces concepts those are bit on the esoteric side of things.<br/>
        Like, being able to test your webapp entirely headless (meaning, no UI) with Protractor.<br/>
        Or, being able to set environment variables. <br/><br/>

        Protractor also enables you to do something called screenshot testing, <br/>
        but it might be better to use Cypress.io for something like that. <br/><br/>

        Starting from Part 3, the book introduces me to CI, <br/>
        which is a system that runs our entire test suite with each changes. <br/><br/>

        enabling us to effortlessly catch issues in a short amount of time (wouldn't it be nice if our QA team actually wrote tests?).
    </p>
    <h4> ch 11</h4>
    <p>
        There is this thing called Karma, which is a test runner (it's weird because test runner isn't really a recognized concept). <br/><br/>

        It executes all the tests and produces a log.<br/><br/>

        Karma can produce a log that can be understood by Jenkins.<br/><br/>

        I was trying to attach a webhook on my repository for Jenkins, but found out that Github doesn't allow localhost.<br/><br/>

        Through this, I can't help but to feel that I will needing a serve of my own for future devops exercises.
    </p>
    <h1>
        Finished the book 
    </h1>
    <p>
        and from the look of things, Angular and Jenkins thing should be done not with the book.

        Non the less, it was a good book.
    </p>
    <h1>
        Was able to spin ng test in Jenkins, but ...
    </h1>
    <p>
        Jenkins wasn't able to run any tests (in the console output) because the browser being used was Chrome.<br/><br/>
        
        After I swtiched the browser in karma.conf.js from Chrome to ChromeHeadless, Jenkins was able to run tests; <br/>
        however, just like when I run ng test in console, Jasmine just spins indefinitly ...<br/>
        <a href="https://github.com/angular/angular-cli/issues/10711">about the above</a><br/><br/>

        However, build is still failing because ... <br/><br/>
        ERROR: Step ‘Archive the artifacts’ failed: No artifacts are configured for archiving. <br/>
        You probably forgot to set the file pattern, so please go back to the configuration and specify it.<br/>
        If you really did mean to archive all the files in the workspace, please specify "**"<br/>
        Recording test results<br/><br/>

        Currently looking at:
        <a href="https://stackoverflow.com/questions/22717187/connect-karma-runner-to-jenkins-ci">this stack overflow post.</a><br/><br/>

        After spinning in the hamsterwheel for good 2 hours, I was able to get the succesful build. <br/><br/>

        I think the key was to follow everything Testin Angular Application has, and chuck in:<br/>
        require('karma-junit-reporter'), <br/>
        and set up the junitReporter to make more sense, <br/>
        and be sure to set <br/>
        singleRun: true,<br/>
        autoWatch: false,<br/><br/>

        and setup the archives for Jenkins configuration to make more sense too, <br/>
        which is underneath the Post-build Actions.<br/><br/>

        Gonna have to brush up on everything that I did to make sure I understand the materials. <br/>
    </p>
    <p>
        <a href="https://docs.microsoft.com/en-us/azure/jenkins/install-jenkins-solution-template">Jenkins and Azure</a> <br/>
        Was going over the above. <br/>
        To do anything with webhooks, Jenkins must be running on a server that's exposed to internet.<br/><br/>

        Weird thing is that, it seems like, when you are using Jenkins on a cloud service, then they obligate you to <br/>
        use other cloud services of theirs that has to do with Dev Ops.<br/><br/>

        I think it's better to ask for a server from one of my Sr engineer.<br/>
        Unfortuantely, almost everyone is on PTO right now.<br/><br/>
    </p>
    <p>
        My manager figured a way to practice CI with Jenkins, I guess I will just leave it to him.<br/><br/>

        However, he got super excited about Docker during his learning, to a point that he's taking executive actions <br/>
        for us have a Docker project.<br/><br/>

        --detached : Detached mode enables the docker container to run in the background. <br/>
        The interactive container can be existed via entering "exit"

        --link : Use it to --link to link a container with a preferred alias.<br/><br/>

        (--tty option doesn't work, -it option actually produced the result I wanted and using the below article <br/>
        <a href='https://stackoverflow.com/questions/30172605/how-do-i-get-into-a-docker-containers-shell'>
            here <br/>
        </a> I was able to produce more result)
        --tty : Starts up a shell environment. This will enable me to pass something to the container that's spnning. <br/>
        When you are in --tty mode, by pressing Ctrl+p+q, I can spin the container in detached mode. <br/><br/>

        --name : Use it to assign name <br/><br/>

        docker exec : executes a command within a container. <br/><br/>

        docker run --pid : Spins a container without any namespace. <br/><br/> 

        docker save : <br/><br/>
        
        docker pull : <br/><br/>

        docker build : builds an image from docker file. <br/><br/>

        docker run --volumes-from : Mount volumes from the specified containers. <br/>
                                    Just a fancy way to state that the option will copy the mount definition<br/>
                                    from a pre-existing container.<br/>

        Docker allows me to run multiple processes within the same container, <br/>
        but it is recommended to give those processes a namespace <br/><br/>

        What's the beauty behind it?<br/>
        Assume that I have to spin 10 severs at once, and this could be hard to orchestrate, <br/>
        but Docker can resolve this quite easily. <br/><br/>

        docker run --detached --name webA nginx:latest <br/>
        docker run --detached --name webB nginx:latest <br/>
        docker run --detached --name webC nginx:latest <br/>
        docker run --detached --name webD nginx:latest <br/>
        So on and so forth ... <br/><br/>

        After marinating myself in Docker in Action for a bit, <br/>
        I think it's easier for my soul to think of containers as headless operating system.<br/><br/>

        It's largely because containers have file hierarchies, enivronment varialbes, <br/> 
        and everything else OS environment has; heck, they even haves things like ports and ip addresses. <br/>
        They can sleep, lock, have a text editor spin in it (maybe not), etc ... <br/>
        it's easier in my mind to think of them as super miniture OS. <br/><br/>

        Docker has a restart policy. By using --restart, I can have a container restart <br/>
        on certain conditions (like, attempt to restart when failure is detected). <br/>
    </p>
    <h1>
        Images
    </h1>
    <p>
        The previous paragraph sang about how Docker containers are easier to be thought of <br/>
        as a super miniture operating system. <br/><br/>

        This ability of containers being a super miniture os comes from this thing called images. <br/><br/>
    </p>
    <h1>
        Layer
    </h1>
    <p>
        Layer is like a parent concept to image because image is a layer, but layer is not an image. <br/>
        Layer is set of files and file metadata, which is distributed atomically, <br/>
        where image could be the file in a particular layer. <br/><br/>
    </p>
    <h1> Images vs Layer</h1>
    <p>
        Layer might be a parent concept to an image, <br/>
        but image is an encapsulation of mutiple layers. <br/>
    </p>
    <h1>
        Registries
    </h1>
    <p>
        Docker has registries, and they are like repositories for Github.<br/><br/>

        For example ... <br/>
        docker pull quay.io/dockerinaction/ch3_hello_registry<br/>
        the above will pull an image called ch3_hello_reigstry from the above URL. <br/><br/>
    </p>
    <h1>
        Container file system
    </h1>
    <p>
        Say, my container is spinning two web apps, and I am starting to think, <br/>
        "where am I going to store all my logs? And how will they outlive their containers?" <br/><br/>

        Image that a container is created from is mounted at that container's file tree root, which implies that <br/>
        mount points in Docker containers can be played around with. <br/><br/>

        Bind Mount: is a technique that utilizes this thing called bind mount points, <br/>
        where user can attach a location on host filesystem to a specific point in a container file.
    </p>
    <h1>
        Bind Mount
    </h1>
    <p>
        A file, or directory, on a host machine is mounted into a container. <br/>
        But you cannot use Docker CLI commands to directly manage the bind mounts.<br/>
    </p>
    <h1>
        Docker Volumes
    </h1>
    <p>
        Docker volumes are named filesystem trees managed by Docker. <br/>
        Which is the preferred way of persisting a data generated and used by Docker containers.<br/>
        The below is a good tutorial for this: <br/>
        <a href="https://vexxhost.com/resources/tutorials/how-to-work-with-docker-data-volumes-on-ubuntu-14-04/">
            How to work with Docker volumes
        </a><br/><br/>

        In the below command:<br/>
        docker create -v /tmp --name newdatacontainer ubuntu <br/>
        -v /tmp is telling docker that, "I want /tmp to be persistable within ubuntu, <br/>
        even after the container has stopped spinning."<br/><br/>

        Then, we ask out selves, "where is all the data persisting?"<br/>
        <a href="https://4sysops.com/archives/introduction-to-docker-bind-mounts-and-volumes/">this</a><br/>
        explains where they are.<br/><br/>

        Lastly, there is a relevant option called --volumes-from <br>
        which is an option for run command in Docker, and it creates a new container <br/>
        that mounts the volume which is already being used.
    </p>
    <h1>
        Dockefile
    </h1>
    <p>
        docker build -t my_image ./ <br/>
        The above command creates an image, with the repository name of my_image (-t option does that), <br/> 
        where ./ tells Docker to find a Dockerfile within the current directory. <br/> 
    </p>
    <h1>
        Just finished the CH 7, and it seems like rest of the book goes over the orchestration stuff with swarm.
    </h1>
    <h1>
        Questions for the Angular experts
    </h1>
    <p>
        Q: How to I detect changes of mutables in services and actions?
        Q: What's the best way to dispatch NgRx stuff for testing?
    </p>
</html>